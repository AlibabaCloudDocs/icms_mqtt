# MQTT 与 RocketMQ 的应用场景对比 {#concept_94521_zh .concept}

本文主要在[ZH-CN\_TP\_152377.md\#](intl.zh-CN/产品简介/什么是微消息队列 MQTT？.md#)的基础上介绍微消息队列 MQTT 和传统消息中间件的关联和区别，并针对实际应用场景下的产品选型给出建议。

## 背景信息 {#section_fv5_3xn_hhb .section}

传统的消息中间件，例如消息队列 RocketMQ、消息队列 Kafka 等都是面向微服务大数据等领域，负责消息的存储和转发，消息的生产者和消费者都是服务端应用。

这种设计很适合服务端技术栈固定、语言平台固定的场景。而移动互联网和 IoT 领域则有所不同，这类场景更侧重于多语言多平台的海量设备接入，消息的生产和消费过程的业务属性很突出，传统的消息中间件并不适合这些领域。

秉承单一职责的原则，微消息队列 MQTT 在设计上是一个面向移动互联网和 IoT 领域的无状态网关，只关心海量移动端设备的接入、管理和消息传输，消息数据的存储则都会路由给后端存储产品，例如传统的消息中间件消息队列 RocketMQ、消息队列 Kafka 等产品。

在这种职责划分下，终端设备将消息发送到微消息队列 MQTT 后，消息会根据微消息队列 MQTT 绑定的存储产品被路由到指定产品，云端应用依然可以维持传统的微服务开发方案，通过对接云端存储产品即可和终端设备进行互动，两者之间通过微消息队列 MQTT 实现了数据互通能力。

## 适用场景对比 {#section_9dd_n57_f6w .section}

在一个业务场景中，可能包含多种不同类型的应用组件，每个组件承担不同的角色。因此，在方案选型时如需要使用到消息产品，需要先了解微消息队列 MQTT 和传统消息中间件的关联和区别，合理搭配使用，比如组件 A 的消息收发使用微消息队列 MQTT，组件 B 的消息收发使用消息队列 RocketMQ。

下文将根据场景举例描述微消息队列 MQTT 和传统的消息中间件的区别，为方便描述，传统的消息中间件以消息队列 RocketMQ 为例，其他产品例如消息队列 Kafka 和消息队列 AMQP（RabbitMQ）同理。

|产品名|适用场景|
|---|----|
| 微消息队列 MQTT

 |面向移动端场景，移动端场景一般都具备海量设备，单设备数据较少的特点。因此，微消息队列 MQTT 适用于拥有大量在线客户端（很多企业设备端过万，甚至上百万），但每个客户端消息较少的场景。|
|消息队列 RocketMQ|面向服务端的消息引擎，主要用于服务组件之间的解耦、异步通知、削峰填谷等，服务器规模较小（极少企业服务器规模过万），但需要大量的消息处理，吞吐量要求高。因此，消息队列 RocketMQ 适用于服务端进行大批量的数据处理和分析的场景。|

## 组合使用场景示例 {#section_5uc_xru_06w .section}

-   **场景示例一**

    在物联网 IoT 场景中，成千上万（甚至数百万）规模的设备传感器可使用微消息队列 MQTT 上传数据，需做数据分析的服务端（即部署在服务器上的应用）则可以通过消息队列 RocketMQ 完成数据的分析与处理。

-   **场景示例二**

    在车联网场景中，上百万辆车需要上传车辆信息数据到云端（服务端），云端同时也会下发指令到任意车辆或广播到所有的车辆。车辆可以通过 MQTT SDK 连接到微消息队列 MQTT 实现数据上报以及指令接收，监管系统（数据分析系统）可以通过消息队列 RocketMQ 的 SDK 进行消息订阅以及指令下发。如下图所示：


 ![](images/43210_zh-CN.png "场景示例")

基于以上区别，推荐您在移动端设备上使用微消息队列 MQTT，而在服务端应用中则使用消息队列 RocketMQ（或者其他消息产品）。

## 功能对比 {#section_cy5_9o1_1hc .section}

微消息队列 MQTT 和消息队列 RocketMQ 的具体功能特性的对比如下：

|功能特性|微消息队列 MQTT|消息队列 RocketMQ|
|----|----------|-------------|
|客户端连接数|客户端规模庞大，百万甚至千万级|一般服务器规模较小，极少数万级|
|单客户端消息量|单个客户端需要处理的消息少，一般定时收发消息|单个客户端处理消息量大，注重吞吐量|
|部署场景|移动设备、App 软件、H5 页面等|服务端应用|
|消费模式|支持广播模式|支持[集群消费和广播消费](https://help.aliyun.com/document_detail/43163.html?spm=a2c4g.11174283.6.658.7369449cI7gOfB)|
|顺序支持|只支持上行顺序，不支持下行顺序（后续开放）|支持上行和下行顺序|
|多语言/系统支持（TCP 协议）|支持 Java、C、C++、.NET、Andriod、iOS、Python、JS、Go 等多种语言和系统|支持 Java、C++、.NET|
|访问凭证|支持 RAM 的永久访问模式和 MQTT Token 的临时访问模式，详情请参见[鉴权概述](../intl.zh-CN/权限验证/鉴权概述.md#)。|支持 [RAM 永久访问模式](https://help.aliyun.com/document_detail/61382.html?spm=a2c4g.11186623.6.637.2d0f313c48Je3R)和 [STS 临时授权访问](https://help.aliyun.com/document_detail/93844.html?spm=a2c4g.11186623.6.638.8dcc7d46McdPx5)|

## 选型指导 {#section_yd0_t01_qf5 .section}

基本原则总结如下：

-   对于部署在服务器上的应用，推荐使用消息队列 RocketMQ 接入;

-   对于部署在移动终端、App 或浏览器页面等平台上的应用，推荐使用微消息队列 MQTT 接入。


针对常见的应用场景，建议的微消息队列 MQTT 和消息队列 RocketMQ 选型如下：

|场景|部署端|微消息队列 MQTT|消息队列 RocketMQ|
|--|---|----------|-------------|
|设备端上报状态数据|移动终端|√|×|
|接收并处理分析设备的上报数据|移动终端|×|√|
|对多个设备下发控制指令|服务器|×|√|
|直播、弹幕、聊天 App 收发消息|应用|√|×|
|服务端接收并分析聊天消息|服务器|×|√|

**说明：** 

√ 表示建议使用该消息队列产品；× 表示不建议使用该消息队列产品。

